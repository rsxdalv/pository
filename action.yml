name: 'Push to Pository'
description: 'Upload a Debian package to a Pository instance'
author: 'Pository Contributors'

inputs:
  host:
    description: 'URL of the Pository instance (e.g., https://pository.example.com)'
    required: true
  api-key:
    description: 'API key with write permission for the Pository instance'
    required: true
  file:
    description: 'Path to the Debian package file to upload'
    required: true
  repo:
    description: 'Repository name in Pository'
    required: false
    default: 'default'
  distribution:
    description: 'Distribution name (e.g., stable, unstable)'
    required: false
    default: 'stable'
  component:
    description: 'Component name (e.g., main, contrib)'
    required: false
    default: 'main'

outputs:
  package-name:
    description: 'Name of the uploaded package'
    value: ${{ steps.upload.outputs.package-name }}
  package-version:
    description: 'Version of the uploaded package'
    value: ${{ steps.upload.outputs.package-version }}
  package-architecture:
    description: 'Architecture of the uploaded package'
    value: ${{ steps.upload.outputs.package-architecture }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [ -z "${{ inputs.host }}" ]; then
          echo "::error::Host URL is required"
          exit 1
        fi
        if [ -z "${{ inputs.api-key }}" ]; then
          echo "::error::API key is required"
          exit 1
        fi
        
        # Safely expand file pattern using find with null-terminated output
        # This prevents command injection from malformed input
        FILE_PATTERN="${{ inputs.file }}"
        
        # If it looks like a glob pattern, use it; otherwise treat as literal path
        if [[ "$FILE_PATTERN" == *"*"* ]] || [[ "$FILE_PATTERN" == *"?"* ]]; then
          # Extract directory and pattern
          FILE_DIR=$(dirname "$FILE_PATTERN")
          FILE_NAME=$(basename "$FILE_PATTERN")
          
          # Find matching files safely
          if [ -d "$FILE_DIR" ]; then
            PACKAGE_FILE=$(find "$FILE_DIR" -maxdepth 1 -name "$FILE_NAME" -type f | head -1)
          else
            PACKAGE_FILE=""
          fi
        else
          # Treat as literal path
          PACKAGE_FILE="$FILE_PATTERN"
        fi
        
        if [ -z "$PACKAGE_FILE" ] || [ ! -f "$PACKAGE_FILE" ]; then
          echo "::error::Package file not found: ${{ inputs.file }}"
          exit 1
        fi
        
        echo "PACKAGE_FILE_PATH=${PACKAGE_FILE}" >> $GITHUB_ENV
        echo "Found package file: ${PACKAGE_FILE}"
        
        echo "✓ All inputs validated successfully"

    - name: Upload package to Pository
      id: upload
      shell: bash
      env:
        POSITORY_HOST: ${{ inputs.host }}
        POSITORY_API_KEY: ${{ inputs.api-key }}
        REPO: ${{ inputs.repo }}
        DIST: ${{ inputs.distribution }}
        COMPONENT: ${{ inputs.component }}
      run: |
        # Use the validated file from environment
        PACKAGE_FILE="${{ env.PACKAGE_FILE_PATH }}"
        
        echo "Uploading package to Pository..."
        echo "Host: ${POSITORY_HOST}"
        echo "Repository: ${REPO}"
        echo "Distribution: ${DIST}"
        echo "Component: ${COMPONENT}"
        echo "Package: ${PACKAGE_FILE}"
        
        # Extract package metadata from filename (format: name_version_arch.deb)
        FILENAME=$(basename "${PACKAGE_FILE}")
        echo "Filename: ${FILENAME}"
        
        # Attempt to extract metadata
        if [[ "$FILENAME" =~ ^(.+)_(.+)_(.+)\.deb$ ]]; then
          PKG_NAME="${BASH_REMATCH[1]}"
          PKG_VERSION="${BASH_REMATCH[2]}"
          PKG_ARCH="${BASH_REMATCH[3]}"
          echo "Extracted metadata: ${PKG_NAME} ${PKG_VERSION} ${PKG_ARCH}"
          echo "package-name=${PKG_NAME}" >> $GITHUB_OUTPUT
          echo "package-version=${PKG_VERSION}" >> $GITHUB_OUTPUT
          echo "package-architecture=${PKG_ARCH}" >> $GITHUB_OUTPUT
        fi
        
        # Upload the package
        # Use RUNNER_TEMP or mktemp for response file to avoid race conditions
        RESPONSE_FILE="${RUNNER_TEMP:-/tmp}/pository-response-$$.json"
        
        # Use environment variable for API key to avoid exposure in process list
        HTTP_CODE=$(curl -X POST "${POSITORY_HOST}/api/v1/packages" \
          -H "X-Api-Key: ${POSITORY_API_KEY}" \
          -F "repo=${REPO}" \
          -F "distribution=${DIST}" \
          -F "component=${COMPONENT}" \
          -F "file=@${PACKAGE_FILE}" \
          -w "%{http_code}" \
          -o "${RESPONSE_FILE}" \
          -s)
        
        # Check response
        if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
          echo "✓ Package uploaded successfully (HTTP ${HTTP_CODE})"
          if [ -f "${RESPONSE_FILE}" ]; then
            echo "Response:"
            cat "${RESPONSE_FILE}"
            rm -f "${RESPONSE_FILE}"
          fi
        else
          echo "::error::Failed to upload package (HTTP ${HTTP_CODE})"
          if [ -f "${RESPONSE_FILE}" ]; then
            echo "Error response:"
            cat "${RESPONSE_FILE}"
            rm -f "${RESPONSE_FILE}"
          fi
          exit 1
        fi

branding:
  icon: 'upload-cloud'
  color: 'blue'
