name: 'Push to Pository'
description: 'Upload one or more Debian packages to a Pository instance'
author: 'Pository Contributors'

inputs:
  host:
    description: 'URL of the Pository instance (e.g., https://pository.example.com)'
    required: true
  api-key:
    description: 'API key with write permission for the Pository instance'
    required: true
  file:
    description: >
      Path(s) to the Debian package file(s) to upload.
      Accepts a single path, a glob pattern (e.g. dist/*.deb), or a
      newline-separated list of paths/patterns.  All matching files are
      uploaded.
    required: true
  repo:
    description: 'Repository name in Pository'
    required: false
    default: 'default'
  distribution:
    description: 'Distribution name (e.g., stable, unstable)'
    required: false
    default: 'stable'
  component:
    description: 'Component name (e.g., main, contrib)'
    required: false
    default: 'main'

outputs:
  package-name:
    description: 'Name of the last uploaded package'
    value: ${{ steps.upload.outputs.package-name }}
  package-version:
    description: 'Version of the last uploaded package'
    value: ${{ steps.upload.outputs.package-version }}
  package-architecture:
    description: 'Architecture of the last uploaded package'
    value: ${{ steps.upload.outputs.package-architecture }}
  packages-uploaded:
    description: 'Total number of packages successfully uploaded'
    value: ${{ steps.upload.outputs.packages-uploaded }}

runs:
  using: 'composite'
  steps:
    - name: Resolve package files
      shell: bash
      run: |
        if [ -z "${{ inputs.host }}" ]; then
          echo "::error::Host URL is required"
          exit 1
        fi
        if [ -z "${{ inputs.api-key }}" ]; then
          echo "::error::API key is required"
          exit 1
        fi

        # Expand every entry in the (possibly newline-separated) file input.
        # Each entry may be a literal path or a glob pattern.
        RESOLVED_FILES=()
        while IFS= read -r ENTRY; do
          # Skip blank lines
          [[ -z "$ENTRY" ]] && continue

          if [[ "$ENTRY" == *"*"* ]] || [[ "$ENTRY" == *"?"* ]]; then
            FILE_DIR=$(dirname "$ENTRY")
            FILE_NAME=$(basename "$ENTRY")
            if [ -d "$FILE_DIR" ]; then
              while IFS= read -r -d '' F; do
                RESOLVED_FILES+=("$F")
              done < <(find "$FILE_DIR" -maxdepth 1 -name "$FILE_NAME" -type f -print0 | sort -z)
            fi
          else
            if [ -f "$ENTRY" ]; then
              RESOLVED_FILES+=("$ENTRY")
            else
              echo "::warning::File not found, skipping: $ENTRY"
            fi
          fi
        done <<< "${{ inputs.file }}"

        if [ "${#RESOLVED_FILES[@]}" -eq 0 ]; then
          echo "::error::No package files found matching: ${{ inputs.file }}"
          exit 1
        fi

        echo "Found ${#RESOLVED_FILES[@]} package file(s):"
        printf '  %s\n' "${RESOLVED_FILES[@]}"

        # Store as newline-delimited list in GITHUB_ENV
        {
          echo 'PACKAGE_FILES<<__EOF__'
          printf '%s\n' "${RESOLVED_FILES[@]}"
          echo '__EOF__'
        } >> "$GITHUB_ENV"

        echo "✓ All inputs validated successfully"

    - name: Upload packages to Pository
      id: upload
      shell: bash
      env:
        POSITORY_HOST: ${{ inputs.host }}
        POSITORY_API_KEY: ${{ inputs.api-key }}
        REPO: ${{ inputs.repo }}
        DIST: ${{ inputs.distribution }}
        COMPONENT: ${{ inputs.component }}
      run: |
        echo "Uploading to Pository..."
        echo "Host:         ${POSITORY_HOST}"
        echo "Repository:   ${REPO}"
        echo "Distribution: ${DIST}"
        echo "Component:    ${COMPONENT}"
        echo ""

        UPLOAD_COUNT=0
        LAST_PKG_NAME=""
        LAST_PKG_VERSION=""
        LAST_PKG_ARCH=""

        # Iterate over every resolved file (newline-delimited env var)
        while IFS= read -r PACKAGE_FILE; do
          [[ -z "$PACKAGE_FILE" ]] && continue

          FILENAME=$(basename "${PACKAGE_FILE}")
          echo "──────────────────────────────────────────"
          echo "Uploading: ${FILENAME}"

          # Extract metadata with dpkg-deb (most reliable)
          PKG_NAME=""
          PKG_VERSION=""
          PKG_ARCH=""
          if command -v dpkg-deb > /dev/null 2>&1; then
            PKG_NAME=$(dpkg-deb --field "${PACKAGE_FILE}" Package 2>/dev/null || true)
            PKG_VERSION=$(dpkg-deb --field "${PACKAGE_FILE}" Version 2>/dev/null || true)
            PKG_ARCH=$(dpkg-deb --field "${PACKAGE_FILE}" Architecture 2>/dev/null || true)
            if [ -n "$PKG_NAME" ]; then
              echo "Metadata (dpkg-deb): ${PKG_NAME} ${PKG_VERSION} ${PKG_ARCH}"
            fi
          fi

          # Fall back to filename parsing for xz/zstd packages
          if [ -z "$PKG_NAME" ]; then
            if [[ "$FILENAME" =~ ^(.+)_([^_]+)_([^_]+)\.deb$ ]]; then
              PKG_NAME="${BASH_REMATCH[1]}"
              PKG_VERSION="${BASH_REMATCH[2]}"
              PKG_ARCH="${BASH_REMATCH[3]}"
              echo "Metadata (filename): ${PKG_NAME} ${PKG_VERSION} ${PKG_ARCH}"
            fi
          fi

          # Use a secure temp file for the response body
          if [ -n "$RUNNER_TEMP" ]; then
            RESPONSE_FILE=$(mktemp "${RUNNER_TEMP}/pository-response-XXXXXX.json")
          else
            RESPONSE_FILE=$(mktemp /tmp/pository-response-XXXXXX.json)
          fi

          HTTP_CODE=$(curl -X POST "${POSITORY_HOST}/api/v1/packages" \
            -H "X-Api-Key: ${POSITORY_API_KEY}" \
            -F "repo=${REPO}" \
            -F "distribution=${DIST}" \
            -F "component=${COMPONENT}" \
            -F "file=@${PACKAGE_FILE}" \
            -w "%{http_code}" \
            -o "${RESPONSE_FILE}" \
            -s)

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "✓ Uploaded successfully (HTTP ${HTTP_CODE})"
            cat "${RESPONSE_FILE}"
            UPLOAD_COUNT=$((UPLOAD_COUNT + 1))
            LAST_PKG_NAME="${PKG_NAME}"
            LAST_PKG_VERSION="${PKG_VERSION}"
            LAST_PKG_ARCH="${PKG_ARCH}"
          else
            echo "::error::Failed to upload ${FILENAME} (HTTP ${HTTP_CODE})"
            cat "${RESPONSE_FILE}"
            rm -f "${RESPONSE_FILE}"
            exit 1
          fi

          rm -f "${RESPONSE_FILE}"
        done <<< "${PACKAGE_FILES}"

        echo "══════════════════════════════════════════"
        echo "✓ Uploaded ${UPLOAD_COUNT} package(s) successfully"

        # Emit outputs (reflect the last uploaded package)
        echo "package-name=${LAST_PKG_NAME}" >> "$GITHUB_OUTPUT"
        echo "package-version=${LAST_PKG_VERSION}" >> "$GITHUB_OUTPUT"
        echo "package-architecture=${LAST_PKG_ARCH}" >> "$GITHUB_OUTPUT"
        echo "packages-uploaded=${UPLOAD_COUNT}" >> "$GITHUB_OUTPUT"

branding:
  icon: 'upload-cloud'
  color: 'blue'
